# -*- coding:UTF-8 -*-
#!/usr/bin/python

"""
Custom topology for Mininet, generated by GraphML-Topo-to-Mininet-Network-Generator.
"""
from mininet.topo import Topo
from mininet.net import Mininet
from mininet.node import RemoteController
from mininet.node import Node
from mininet.node import CPULimitedHost
from mininet.link import TCLink
from mininet.cli import CLI
from mininet.log import setLogLevel
from mininet.util import dumpNodeConnections
from time import sleep
from mininet.util import quietRun
from mininet.log import setLogLevel,info
import random
import sys
import time
import os
from threading import Thread
import multiprocessing
from scapy.all import *
##Build Your Topo
class GeneratedTopo( Topo ):
    "Internet Topology Zoo Specimen."

    def __init__( self, **opts ):
        "Create a topology."

        # Initialize Topology
        Topo.__init__( self, **opts )

        # add nodes, switches first...
        NL = self.addSwitch( 's0',failMode='standalone',stp=True)
        BE = self.addSwitch( 's1',failMode='standalone',stp=True)
        DK = self.addSwitch( 's2',failMode='standalone',stp=True)
        PL = self.addSwitch( 's3',failMode='standalone',stp=True)
        DE = self.addSwitch( 's4',failMode='standalone',stp=True)
        CZ = self.addSwitch( 's5',failMode='standalone',stp=True)
        LU = self.addSwitch( 's6',failMode='standalone',stp=True)
        FR = self.addSwitch( 's7',failMode='standalone',stp=True)
        CH = self.addSwitch( 's8',failMode='standalone',stp=True)
        IT = self.addSwitch( 's9',failMode='standalone',stp=True)
        UA = self.addSwitch( 's10',failMode='standalone',stp=True)
        MD = self.addSwitch( 's11',failMode='standalone',stp=True)
        BG = self.addSwitch( 's12',failMode='standalone',stp=True)
        RO = self.addSwitch( 's13',failMode='standalone',stp=True)
        TR = self.addSwitch( 's14',failMode='standalone',stp=True)
        GR = self.addSwitch( 's15',failMode='standalone',stp=True)
        CY = self.addSwitch( 's16',failMode='standalone',stp=True)
        IL = self.addSwitch( 's17',failMode='standalone',stp=True)
        MT = self.addSwitch( 's18',failMode='standalone',stp=True)
        BY = self.addSwitch( 's19',failMode='standalone',stp=True)
        MK = self.addSwitch( 's20',failMode='standalone',stp=True)
        ME = self.addSwitch( 's21',failMode='standalone',stp=True)
        HU = self.addSwitch( 's22',failMode='standalone',stp=True)
        SK = self.addSwitch( 's23',failMode='standalone',stp=True)
        PT = self.addSwitch( 's24',failMode='standalone',stp=True)
        ES = self.addSwitch( 's25',failMode='standalone',stp=True)
        RS = self.addSwitch( 's26',failMode='standalone',stp=True)
        HR = self.addSwitch( 's27',failMode='standalone',stp=True)
        SL = self.addSwitch( 's28',failMode='standalone',stp=True)
        AT = self.addSwitch( 's29',failMode='standalone',stp=True)
        LT = self.addSwitch( 's30',failMode='standalone',stp=True)
        RU = self.addSwitch( 's31',failMode='standalone',stp=True)
        IS = self.addSwitch( 's32',failMode='standalone',stp=True)
        IE = self.addSwitch( 's33',failMode='standalone',stp=True)
        UK = self.addSwitch( 's34',failMode='standalone',stp=True)
        NO = self.addSwitch( 's35',failMode='standalone',stp=True)
        SE = self.addSwitch( 's36',failMode='standalone',stp=True)
        FI = self.addSwitch( 's37',failMode='standalone',stp=True)
        EE = self.addSwitch( 's38',failMode='standalone',stp=True)
        LV = self.addSwitch( 's39',failMode='standalone',stp=True)

        # ... and now hosts
        NL_host = self.addHost( 'h0',ip='192.168.123.1')
        BE_host = self.addHost( 'h1',ip='192.168.123.2')
        DK_host = self.addHost( 'h2',ip='192.168.123.3')
        PL_host = self.addHost( 'h3',ip='192.168.123.4')
        DE_host = self.addHost( 'h4',ip='192.168.123.5')
        CZ_host = self.addHost( 'h5',ip='192.168.123.6')
        LU_host = self.addHost( 'h6',ip='192.168.123.7')
        FR_host = self.addHost( 'h7',ip='192.168.123.8')
        CH_host = self.addHost( 'h8',ip='192.168.123.9')
        IT_host = self.addHost( 'h9',ip='192.168.123.10')
        UA_host = self.addHost( 'h10',ip='192.168.123.11')
        MD_host = self.addHost( 'h11',ip='192.168.123.12')
        BG_host = self.addHost( 'h12',ip='192.168.123.13')
        RO_host = self.addHost( 'h13',ip='192.168.123.14')
        TR_host = self.addHost( 'h14',ip='192.168.123.15')
        GR_host = self.addHost( 'h15',ip='192.168.123.16')
        CY_host = self.addHost( 'h16',ip='192.168.123.17')
        IL_host = self.addHost( 'h17',ip='192.168.123.18')
        MT_host = self.addHost( 'h18',ip='192.168.123.19')
        BY_host = self.addHost( 'h19',ip='192.168.123.20')
        MK_host = self.addHost( 'h20',ip='192.168.123.21')
        ME_host = self.addHost( 'h21',ip='192.168.123.22')
        HU_host = self.addHost( 'h22',ip='192.168.123.23')
        SK_host = self.addHost( 'h23',ip='192.168.123.24')
        PT_host = self.addHost( 'h24',ip='192.168.123.25')
        ES_host = self.addHost( 'h25',ip='192.168.123.26')
        RS_host = self.addHost( 'h26',ip='192.168.123.27')
        HR_host = self.addHost( 'h27',ip='192.168.123.28')
        SL_host = self.addHost( 'h28',ip='192.168.123.29')
        AT_host = self.addHost( 'h29',ip='192.168.123.30')
        LT_host = self.addHost( 'h30',ip='192.168.123.31')
        RU_host = self.addHost( 'h31',ip='192.168.123.32')
        IS_host = self.addHost( 'h32',ip='192.168.123.33')
        IE_host = self.addHost( 'h33',ip='192.168.123.34')
        UK_host = self.addHost( 'h34',ip='192.168.123.35')
        NO_host = self.addHost( 'h35',ip='192.168.123.36')
        SE_host = self.addHost( 'h36',ip='192.168.123.37')
        FI_host = self.addHost( 'h37',ip='192.168.123.38')
        EE_host = self.addHost( 'h38',ip='192.168.123.39')
        LV_host = self.addHost( 'h39',ip='192.168.123.40')

        # add edges between switch and corresponding host
        self.addLink( NL , NL_host )
        self.addLink( BE , BE_host )
        self.addLink( DK , DK_host )
        self.addLink( PL , PL_host )
        self.addLink( DE , DE_host )
        self.addLink( CZ , CZ_host )
        self.addLink( LU , LU_host )
        self.addLink( FR , FR_host )
        self.addLink( CH , CH_host )
        self.addLink( IT , IT_host )
        self.addLink( UA , UA_host )
        self.addLink( MD , MD_host )
        self.addLink( BG , BG_host )
        self.addLink( RO , RO_host )
        self.addLink( TR , TR_host )
        self.addLink( GR , GR_host )
        self.addLink( CY , CY_host )
        self.addLink( IL , IL_host )
        self.addLink( MT , MT_host )
        self.addLink( BY , BY_host )
        self.addLink( MK , MK_host )
        self.addLink( ME , ME_host )
        self.addLink( HU , HU_host )
        self.addLink( SK , SK_host )
        self.addLink( PT , PT_host )
        self.addLink( ES , ES_host )
        self.addLink( RS , RS_host )
        self.addLink( HR , HR_host )
        self.addLink( SL , SL_host )
        self.addLink( AT , AT_host )
        self.addLink( LT , LT_host )
        self.addLink( RU , RU_host )
        self.addLink( IS , IS_host )
        self.addLink( IE , IE_host )
        self.addLink( UK , UK_host )
        self.addLink( NO , NO_host )
        self.addLink( SE , SE_host )
        self.addLink( FI , FI_host )
        self.addLink( EE , EE_host )
        self.addLink( LV , LV_host )

        # add edges between switches
        self.addLink( NL , BE, bw=10, delay='0.881602073532ms')
        self.addLink( NL , DK, bw=10, delay='3.15513777465ms')
        self.addLink( NL , DE, bw=10, delay='1.85097779786ms')
        self.addLink( NL , UK, bw=10, delay='1.81386031274ms')
        self.addLink( NL , LT, bw=10, delay='6.50520470549ms')
        self.addLink( BE , IE, bw=10, delay='3.940707129ms')
        self.addLink( DK , IS, bw=10, delay='10.693177836ms')
        self.addLink( DK , NO, bw=10, delay='3.65071853163ms')
        self.addLink( DK , DE, bw=10, delay='3.40745014815ms')
        self.addLink( DK , EE, bw=10, delay='4.25320528086ms')
        self.addLink( DK , SE, bw=10, delay='2.65465761513ms')
        self.addLink( DK , RU, bw=10, delay='7.9304651598ms')
        self.addLink( PL , UA, bw=10, delay='4.86914479145ms')
        self.addLink( PL , BY, bw=10, delay='9.38314340321ms')
        self.addLink( PL , DE, bw=10, delay='3.20168442207ms')
        self.addLink( PL , CZ, bw=10, delay='1.59420969693ms')
        self.addLink( PL , LT, bw=10, delay='2.71103227044ms')
        self.addLink( DE , CZ, bw=10, delay='2.0790736324ms')
        self.addLink( DE , LU, bw=10, delay='0.972779743885ms')
        self.addLink( DE , CH, bw=10, delay='1.84916730215ms')
        self.addLink( DE , CY, bw=10, delay='13.1817956528ms')
        self.addLink( DE , IL, bw=10, delay='15.1814365297ms')
        self.addLink( DE , AT, bw=10, delay='3.03704628873ms')
        self.addLink( DE , RU, bw=10, delay='10.2681573666ms')
        self.addLink( CZ , SK, bw=10, delay='1.47913602086ms')
        self.addLink( LU , FR, bw=10, delay='1.45933857287ms')
        self.addLink( FR , CH, bw=10, delay='2.21066968647ms')
        self.addLink( FR , ES, bw=10, delay='5.348356256ms')
        self.addLink( FR , UK, bw=10, delay='1.74698472095ms')
        self.addLink( CH , IT, bw=10, delay='1.08028877403ms')
        self.addLink( CH , ES, bw=10, delay='5.85389618173ms')
        self.addLink( IT , ES, bw=10, delay='6.03783369003ms')
        self.addLink( IT , MT, bw=10, delay='5.84357521277ms')
        self.addLink( IT , AT, bw=10, delay='3.17829966322ms')
        self.addLink( IT , GR, bw=10, delay='7.4267171232ms')
        self.addLink( MD , RO, bw=10, delay='6.77793918829ms')
        self.addLink( BG , TR, bw=10, delay='5.35486475467ms')
        self.addLink( BG , MK, bw=10, delay='0.882520207681ms')
        self.addLink( BG , RO, bw=10, delay='1.50267595503ms')
        self.addLink( BG , HU, bw=10, delay='3.20487785785ms')
        self.addLink( BG , GR, bw=10, delay='2.67138433207ms')
        self.addLink( RO , HU, bw=10, delay='3.26984497583ms')
        self.addLink( RO , TR, bw=10, delay='4.791067078ms')
        self.addLink( GR , AT, bw=10, delay='6.51915802808ms')
        self.addLink( CY , UK, bw=10, delay='16.3537848536ms')
        self.addLink( IL , LT, bw=10, delay='13.9199230299ms')
        self.addLink( ME , HR, bw=10, delay='2.3253631715ms')
        self.addLink( HU , RS, bw=10, delay='1.62124691159ms')
        self.addLink( HU , HR, bw=10, delay='1.52143483968ms')
        self.addLink( HU , SK, bw=10, delay='0.820283041457ms')
        self.addLink( SK , AT, bw=10, delay='0.278909482113ms')
        self.addLink( PT , ES, bw=10, delay='2.55266595125ms')
        self.addLink( PT , UK, bw=10, delay='8.05742746868ms')
        self.addLink( HR , SL, bw=10, delay='0.594079321939ms')
        self.addLink( SL , AT, bw=10, delay='1.41458071877ms')
        self.addLink( LT , LV, bw=10, delay='1.15797533567ms')
        self.addLink( IS , UK, bw=10, delay='9.59015203521ms')
        self.addLink( IE , UK, bw=10, delay='2.35560572039ms')
        self.addLink( NO , SE, bw=10, delay='2.6908436486ms')
        self.addLink( SE , FI, bw=10, delay='1.34860652011ms')
        self.addLink( EE , LV, bw=10, delay='1.42071288026ms')


##Thread of traffic,py
class TrafficThread(Thread):
    def __init__(self,h1,h2):
        self.h1=h1
        self.h2=h2
        Thread.__init__(self)
    def run(self):
        print(self.h1.IP())
        print(self.h2.IP())
        print("HI")
        self.h1.cmd('sudo python /home/ylj/GEANT/test_node/traffic.py %s' % self.h2.IP())

#worker 程序
def worker(h1,h2):
    h1.cmd('sudo python traffic.py '+h2.IP()+' &')
    print('IP is')
    print(h2.IP())

def traffic(net,j):
    list_all=[]
    for i in range(40):
        list_all.append(i)
    list1=random.sample(list_all,20)
    for item in list1:
        if(item in list1):
            list_all.remove(item)
    list2=random.sample(list_all,20)
    f_throughput=open('throughput.txt','a')
    f_throughput.write(str(i)+'\n')
    


    ##加入进程list
    jobs=[]
    for temp in range(20):
        str1=list1[temp]
        for temp2 in range(20):
            str2=list2[temp2]
            h1='h'+str(str1)
            h2='h'+str(str2)
            """
            if(str1==brokennode):
                a=h1
                h1=h2
                h2=a
            print(h1)
            print(h2)
            """
            f_throughput.write(h1+'\t'+h2+'\n')
            node1=net.get(h1)
            node2=net.get(h2)
            print(node1.IP())
            print(node2.IP())
            """
            thread=TrafficThread(node1,node2)
            threads.append(thread)
            thread.start()
            """
        
            p=multiprocessing.Process(target=worker,args=(node1,node2))
            jobs.append(p)
            f_throughput.write('\n')
    ##jobs shuffle
    jobs=random.sample(jobs,len(jobs))
    ##jobs start
    count=0
    stop=int(len(jobs)/2)
    sleep(1)
    pingtest(net,40)
    for p in jobs:
        p.start()
        ### close signal
        """
        if(count==stop):
            pingtest(net,40)
            singledown(net,0,brokennode)
        count+=1
        """
    sleep(10)
    ##wait for close signal
    for p in jobs:
        print('terminate subprocess')
        p.terminate()
    start=time.time()
    judge=start

    while True:
        if(judge-start>=0.5):
            print('kill me')
            f_throughput.close()
            net.stop()
            sys.exit(0)
            break
        judge+=1
        sleep(0.5)


def pingtest(net,n):
    h0=net.hosts[0]
    for i in range(1,n):
        h1=net.hosts[i]
        h0.cmdPrint('ping -Q 0x64 -c 1 '+h1.IP())
    print("PING is OK")

def singledown(net,i,brokennode):
    #count=random.randint(0,41)
    #count=5
    count=brokennode
    node1='s'+str(count)
    node1_neighbors=neighbors[node1]
    print(node1)
    f_brokenswitch=open("brokenswitch.txt",'a')
    f_brokenswitch.write(str(i)+'\t'+node1+'\t')
    for node2 in node1_neighbors:
        print(node2)
        f_brokenswitch.write(node2+'\t')
        net.configLinkStatus(node1,node2,'down')
    f_brokenswitch.write('\n')
    #normal(net,i)
    f_brokenswitch.close()
    print('i have closed')
 


def normal(net,j):
    list_all=[]
    for i in range(40):
        list_all.append(i)
    list1=random.sample(list_all,20)
    for item in list1:
        if(item in list1):
            list_all.remove(item)
    list2=random.sample(list_all,20)
    f_throughput=open('throughput.txt','a')
    f_throughput.write(str(i)+'\n')
    for temp in range(20):
        str1=list1[temp]
        for temp2 in range(1):
            str2=list2[temp2]
            h1='h'+str(str1)
            h2='h'+str(str2)
            if(str1==brokennode):
                a=h1
                h1=h2
                h2=a
            print(h1)
            print(h2)
            f_throughput.write(h1+'\t'+h2+'\n')
            node1=net.get(h1)
            node2=net.get(h2)
            print(node1.IP())
            print(node2.IP())
            data=Raw(RandString(size=1600))
            #node1.cmd("iperf "+'-t 10 -c '+node2.IP()+" & ")
            pkt=IP(src=node1.IP(),dst=node2.IP())/TCP(sport=12345,dport=12345)/data
            send(pkt,inter=0.05,count=1)
        f_throughput.write('\n')
    f_throughput.close()


def brokenlink(net,i):
    dic_keys={}
    f_brokenlink=open('brokenlink.txt','a')
    s_w=random.randint(0,1)
    count=random.randint(2,40)
    node1=''
    if(s_w==0):
        node1='s'+str(count)
    if(s_w==1):
        node1='h'+str(count)
    print(type(node1))
    print(node1)
    if(s_w==0):
        node2=random.choice(neighbors[node1])
    if(s_w==1):
        node2='s'+str(count)
    print(type(node2))
    print(node2)
    f_brokenlink.write(str(i)+'\t'+node1+'\t'+node2+'\t'+'\n')
    f_brokenlink.close()
    net.configLinkStatus(node1,node2,'down')
    normal(net,i)
    sleep(1)
    net.configLinkStatus(node1,node2,'up')
    sleep(2)
    """
    for item1 in net.switches:
        node1=item1.name
        for item2 in neighbors[node1]:
            if(item2[0]=='h'):
                continue
            node2=item2
            print(node1)
            print(node2)
            temp1=node1+'\t'+node2
            temp2=node2+'\t'+node1
            if(temp1 in dic_keys):
                continue
            else:
                dic_keys[temp1]=1
                dic_keys[temp2]=1
            f_brokenlink.write(str(count)+'\t'+node1+'\t'+node2+'\t'+'\n')
            f_brokenlink.close()
            net.configLinkStatus(node1,node2,'down')
            net.pingAll()
            sleep(1)
            net.configLinkStatus(node1,node2,'up')
            count+=1
    """
def brokenlink1(net,node1,node2):
    print(node1)
    print(node2)
    f_brokenlink.write(node1+'\t'+node2+'\t'+'\n')
    net.configLinkStatus(node1,node2,'down')
    net.pingAll()
    sleep(1)
    net.configLinkStatus(node1,node2,'up')
def brokenswitch(net,i,brokennode):
    #count=random.randint(0,41)
    #count=5
    count=brokennode
    node1='s'+str(count)
    node1_neighbors=neighbors[node1]
    print(node1)
    f_brokenswitch=open("brokenswitch.txt",'a')
    f_brokenswitch.write(str(i)+'\t'+node1+'\t')
    for node2 in node1_neighbors:
        print(node2)
        f_brokenswitch.write(node2+'\t')
        net.configLinkStatus(node1,node2,'down')
    f_brokenswitch.write('\n')
    normal(net,i)
    f_brokenswitch.close()
    #sleep(1)
    for node2 in node1_neighbors:
        net.configLinkStatus(node1,node2,'up')
    #sleep(2)
def myNet():
    global brokennode
    brokennode=sys.argv[1]
    print(brokennode)
    net = Mininet(topo=GeneratedTopo(), controller=lambda a: RemoteController(a,ip='127.0.0.1',port=6633),host=CPULimitedHost,link=TCLink)
    #net=Mininet(topo=GeneratedTopo(),host=CPULimitedHost,link=TCLink)
    #net.addController('c0', RemoteController, ip="127.0.0.1",port=6633)
    print("Hello")
    #net.start()
    print("DUmping host coonnections")
    #dumpNodeConnections(net.hosts)
    net.start()
    print("host is OKJ")
    #sleep(10)
    while 'is_connected' not in quietRun('ovs-vsctl show'):
        sleep(1)
        print('.')
    print("Test pingall")
    print(type(net.hosts))
    print(type(net.links))
    global neighbors
    neighbors={}
    global mac
    mac={}
    f_neighbors=open('neighbors.txt','w')
    f_mac=open('mac.txt','w')
    for item in net.hosts:
        list_host=[]
        host_mac={}
        print(type(item.name))
        print(item.name)
        neighbors[item.name]=list_host
        mac[item.name]=host_mac
    for item in net.switches:
        list_switch=[]
        switch_mac={}
        print(type(type(item.name)))
        print(item.name)
        neighbors[item.name]=list_switch
        mac[item.name]=switch_mac
    dic_temp={}
    mac_all={}
    for item in net.links:
        count1=item.intf1.name.find('-')
        count2=item.intf2.name.find('-')
        print(item.intf1.name[:count1])
        print(item.intf2.name[:count2])
        if item.intf1.name not in dic_temp:
            dic_temp[item.intf1.name]=1
        if item .intf2.name not in dic_temp:
            dic_temp[item.intf2.name]=1
        node1=item.intf1.name[:count1]
        node2=item.intf2.name[:count2]
        neighbors[node1].append(node2)
        neighbors[node2].append(node1)
        mac[node1][node2]=item.intf1.mac
        mac[node2][node1]=item.intf2.mac
        mac_all[item.intf1.name]=item.intf1.mac
        mac_all[item.intf2.name]=item.intf2.mac
        print(item.intf1.mac)
        print(item.intf2.mac)
        print(type(item.intf1.mac))
        print(type(item.intf2.mac))
    f_mac_all=open("mac_all.txt",'w')

    for item in mac_all:
        f_mac_all.write(item+'\t'+mac_all[item]+'\t'+'\n')

    for item in neighbors:
        print(item+'\t')
        for temp in neighbors[item]:
            print(temp+'\t')
            f_neighbors.write(item+'\t'+temp+'\n')
        print('\n')
    for item in mac:
        print(item+'\t')
        for temp in mac[item]:
            print(temp+'\t')
            print(mac[item][temp]+'\n')
            f_mac.write(item+'\t'+temp+'\t'+mac[item][temp]+'\n')
        print('\n')
    f_neighbors.close()
    f_mac.close()
    """
    h0=net.hosts[0]
    for item in net.hosts[1:]:
        h0.cmdPrint('ping -Q 0x64 -c 1 '+item.IP())
    """
    
    net.pingAll()
    f_temp=open('tcplook.sh','w')
    for item in dic_temp:
        f_temp.write('sudo tcpdump -i '+item+' -w '+item+'.pcap'+' &'+'\n')
    f_temp.close()
    global tcp_start
    tcp_start=time.time()
    os.system('sh -x tcplook.sh')
    #sleep(2)
    samples=1

    
    for i in range(samples):
        print(i)
        #event=random.randint(0,2)
        event=0
        h0=net.hosts[0]
        h1=net.hosts[1]
        h2=net.hosts[2]
        #h0.cmdPrint('ping -Q 0x64 -c 1 '+h1.IP())
        #sleep(3)
        if(event==0):
            #normal(net,i)
            traffic(net,i)
        if(event==1):
            brokenlink(net,i)
        if(event==2):
            brokenswitch(net,i,brokennode)
        sleep(1)
    net.stop()
if __name__ == "__main__":
    print("GO")
    myNet()
# topos = { 'generated': ( lambda: GeneratedTopo() ) }
